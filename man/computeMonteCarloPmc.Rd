% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Pmc.R
\name{computeMonteCarloPmc}
\alias{computeMonteCarloPmc}
\title{Monte Carlo \eqn{P_{\rm{mc}}} computation}
\usage{
computeMonteCarloPmc(
  paramsList,
  mcSamples = 1e+05,
  batchSize = mcSamples,
  numCores = 1,
  verbose = F
)
}
\arguments{
\item{paramsList}{List containing lists with each component GMM parameters. See \link{constructPmcParamsMclust} for format of components.}

\item{mcSamples}{Numeric for number of MC samples to use to approximate the integral.}

\item{batchSize}{Numeric for the observations to assign to each core. Helps with memory concerns. Default \code{mcSamples}.}

\item{numCores}{Number of cores to use in parallel::mclapply call. Default is 1.}

\item{verbose}{Boolean whether to print output messages}
}
\value{
Monte Carlo estimate of \eqn{P_{\rm mc}}
}
\description{
Compute Monte Carlo estimate of \eqn{P_{\rm mc}} for a given cluster configuration based on estimated GMM densities.
}
\details{
\eqn{P_{\rm{mc}}} can be difficult to evaluate as standard cubature methods tend to perform poorly in higher dimensions.
We can approximate it for a \eqn{K}-cluster configuration using a Monte Carlo integral of the form
\deqn{\hat P_{{\rm mc}} = \frac{1}{M} \sum_{i=1}^{M} \sum_{j=1}^K  \left(1 - \pi_j(x_i) \right) \, \pi_j(x_i)}
Where the \eqn{M} observations are sampled from the overall data density \eqn{P(x)}
}
\examples{
set.seed(1)
dat <- matrix(c(rnorm(200), rnorm(200, 3), rnorm(200, -3)), ncol=2, byrow=T)
partition <- c(rep(1, 100), rep(2, 100), rep(3, 100))
params <- constructPmcParamsPartition(partition, dat, G=1:5)
computeMonteCarloPmc(params, 1e5, verbose=T)

}
